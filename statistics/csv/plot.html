---
title: Plot CSV - Statistics-related tools
layout: default
---
<h1 class="text-center text-color">{{ page.title }}</h1>
{% include _credits/d3.html %}

<div class="p-3 border-color container fs-5 mt-5">
    <p>Please, select the CSV you want to plot</p>

    <input type="file" name="upload" oninput="process()">

    <details class="mt-3 border-color p-3">
        <summary>Options</summary>

        <table  class="table border-color table-bordered table-striped mt-3">
            <tr>
                <td><label for="have_header">The first line is the name of the columns</label></td>
                <td><input id="have_header" type="checkbox" checked></td>
            </tr>
            <tr>
                <td><label for="delimiter">Separator</label></td>
                <td><select id="delimiter">
                    <option name="">autodetect</option>
                    <option name=" ">space</option>
                    <option name=",">comma (,)</option>
                    <option name=";">semi-colon  (;)</option>
                    <option name=":">colon  (;)</option>
                </select></td>
            </tr>
            <tr>
                <td><label for="graphType">Graph Type</label></td>
                <td>
                    <select id="graphType" onchange="changeGraphType()">
                        <option name="line">Line</option>
                        <option name="spline">Spline</option>
                        <option name="step">Step</option>
                        <option name="area">Area</option>
                        <option name="area-step">Area-step</option>
                        <option name="area-spline">Area-spline</option>
                    </select>
                </td>
            </tr>
            <tr id="xAxisRow" hidden=true>
                <td><label for="xAxis">X Axis</label></td>
                <td>
                    <select id="xAxis" onchange="process()">//onchange="changeXAxisFunc()"
                        <option name="">None</option>
                    </select>
                </td>
            </tr>
        </table>
    </details>

    <div class="mt-3 text-end">
        <button onclick="process()">Submit</button>
    </div>

    {% include upload_csv.html %}
    {% include plotLibs.html %}

    <script>
        // Declaring variables that will be used in other functions
        let plot ;
        let csv;
        const delimiter = document.querySelector('#delimiter')
        let graphType = document.querySelector('#graphType')
        const xAxis = document.querySelector('#xAxis');
        const xAxisRow = document.querySelector('#xAxisRow');
        let selectedXAxis;
        let selectedGraphType;

        //
        async function process() {
            let sep = delimiter.selectedOptions.item(0).getAttribute('name');
            selectedXAxis = xAxis.selectedOptions.item(0).getAttribute('name');
            selectedGraphType = graphType.selectedOptions.item(0).getAttribute('name');
            csv = await parseCSVToJson("input", sep);
            if (csv.data == null) {
                results.hidden = false;
                results_div.innerHTML = 'CSV missing';
                return;
            }

            let have_header = document.getElementById('have_header');
            if(have_header.checked){
                for(let i=0; i < csv.data.length;i++){
                    if (csv.data[0].length !== csv.data[i].length){
                        results.hidden = false;
                        results_div.innerHTML = 'CSV format is flawed';
                        return;
                    }
                }
            }

            let headers = [];
            if(!have_header.checked) {
                if(csv.data[0] !== undefined) {
                    for (let i = 0; i < csv.data[0].length; i++) {
                        headers.push("Column "+(i+1))
                    }
                }
                csv.data.unshift(headers);
            }else{
                headers = csv.data[0]
            }

            // Deleting the potentially already existing xAxis options
            let childrenNb = xAxis.length;
            for(let i = 1; i < childrenNb; i++){
                xAxis.removeChild(xAxis.children[xAxis.length-1]);
            }

            // Adding every possible data to the xAxis options
            for(let i = 0 ; i < headers.length ; i++){
                let opt = document.createElement('option');
                opt.innerHTML = headers[i];
                opt.setAttribute('name', headers[i]);
                xAxis.appendChild(opt)
            }
            xAxisRow.hidden = false;

            results.hidden = false;
            plot = await c3.generate({
                bindto: results_div,
                data:{
                    x:selectedXAxis,
                    rows: [] = csv.data,
                    type:selectedGraphType,
                },
                axis: {
                    x: {
                        label: {
                            text: selectedXAxis,
                            position: 'center'
                        }
                    },
                },
                zoom: {
                    enabled: true
                }
            });
        }

        function changeGraphType() {
            selectedGraphType = graphType.selectedOptions.item(0).getAttribute('name');
            switch (selectedGraphType){
                case 'line':
                    plot.transform('line');
                    break;
                case 'spline':
                    plot.transform('spline');
                    break;
                case 'step':
                    plot.transform('step');
                    break;
                case 'area':
                    plot.transform('area');
                    break;
                case 'area-step':
                    plot.transform('area-step');
                    break;
                case 'area-spline':
                    plot.transform('area-spline');
                    break;

            }
        }
    </script>
</div>

{% include _partial/plot_results_div.html %}

<script>
    SVGElement.prototype.toDataURL = function(type, options) {
        var _svg = this;

        function debug(s) {
            console.log("SVG.toDataURL:", s);
        }

        function exportSVG() {
            var svg_xml = XMLSerialize(_svg);
            var svg_dataurl = base64dataURLencode(svg_xml);
            debug(type + " length: " + svg_dataurl.length);

            // NOTE double data carrier
            if (options.callback) options.callback(svg_dataurl);
            return svg_dataurl;
        }

        function XMLSerialize(svg) {

            // quick-n-serialize an SVG dom, needed for IE9 where there's no XMLSerializer nor SVG.xml
            // s: SVG dom, which is the <svg> elemennt
            function XMLSerializerForIE(s) {
                var out = "";

                out += "<" + s.nodeName;
                for (var n = 0; n < s.attributes.length; n++) {
                    out += " " + s.attributes[n].name + "=" + "'" + s.attributes[n].value + "'";
                }

                if (s.hasChildNodes()) {
                    out += ">\n";

                    for (var n = 0; n < s.childNodes.length; n++) {
                        out += XMLSerializerForIE(s.childNodes[n]);
                    }

                    out += "</" + s.nodeName + ">" + "\n";

                } else out += " />\n";

                return out;
            }


            if (window.XMLSerializer) {
                debug("using standard XMLSerializer.serializeToString")
                return (new XMLSerializer()).serializeToString(svg);
            } else {
                debug("using custom XMLSerializerForIE")
                return XMLSerializerForIE(svg);
            }

        }

        function base64dataURLencode(s) {
            var b64 = "data:image/svg+xml;base64,";

            // https://developer.mozilla.org/en/DOM/window.btoa
            if (window.btoa) {
                debug("using window.btoa for base64 encoding");
                b64 += btoa(s);
            } else {
                debug("using custom base64 encoder");
                b64 += Base64.encode(s);
            }

            return b64;
        }

        function exportImage(type) {
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext('2d');

            // TODO: if (options.keepOutsideViewport), do some translation magic?

            var svg_img = new Image();
            var svg_xml = XMLSerialize(_svg);
            svg_img.src = base64dataURLencode(svg_xml);

            svg_img.onload = function() {
                debug("exported image size: " + [svg_img.width, svg_img.height])
                canvas.width = svg_img.width;
                canvas.height = svg_img.height;
                ctx.drawImage(svg_img, 0, 0);

                // SECURITY_ERR WILL HAPPEN NOW
                var png_dataurl = canvas.toDataURL(type);
                debug(type + " length: " + png_dataurl.length);

                if (options.callback) options.callback( png_dataurl );
                else debug("WARNING: no callback set, so nothing happens.");
            }

            svg_img.onerror = function() {
                console.log(
                    "Can't export! Maybe your browser doesn't support " +
                    "SVG in img element or SVG input for Canvas drawImage?\n" +
                    "http://en.wikipedia.org/wiki/SVG#Native_support"
                );
            }

            // NOTE: will not return anything
        }

        function exportImageCanvg(type) {
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext('2d');
            var svg_xml = XMLSerialize(_svg);
            console.log(svg_xml);
            // NOTE: canvg gets the SVG element dimensions incorrectly if not specified as attributes
            //debug("detected svg dimensions " + [_svg.clientWidth, _svg.clientHeight])
            //debug("canvas dimensions " + [canvas.width, canvas.height])

            var keepBB = options.keepOutsideViewport;
            if (keepBB) var bb = _svg.getBBox();

            // NOTE: this canvg call is synchronous and blocks
            canvg(canvas, svg_xml, {
                ignoreMouse: true, ignoreAnimation: true,
                offsetX: keepBB ? -bb.x : undefined,
                offsetY: keepBB ? -bb.y : undefined,
                scaleWidth: keepBB ? bb.width+bb.x : undefined,
                scaleHeight: keepBB ? bb.height+bb.y : undefined,
                renderCallback: function() {
                    debug("exported image dimensions " + [canvas.width, canvas.height]);
                    var png_dataurl = canvas.toDataURL(type);
                    debug(type + " length: " + png_dataurl.length);

                    if (options.callback) options.callback( png_dataurl );
                },
                useCORS: false
            });

            // NOTE: return in addition to callback
            return canvas.toDataURL(type);
        }

        // BEGIN MAIN

        if (!type) type = "image/svg+xml";
        if (!options) options = {};

        if (options.keepNonSafe) debug("NOTE: keepNonSafe is NOT supported and will be ignored!");
        if (options.keepOutsideViewport) debug("NOTE: keepOutsideViewport is only supported with canvg exporter.");

        switch (type) {
            case "image/svg+xml":
                return exportSVG();
                break;

            case "image/png":
            case "image/jpeg":

                if (!options.renderer) {
                    if (window.canvg) options.renderer = "canvg";
                    else options.renderer="native";
                }

                switch (options.renderer) {
                    case "canvg":
                        debug("using canvg renderer for png export");
                        return exportImageCanvg(type);
                        break;

                    case "native":
                        debug("using native renderer for png export. THIS MIGHT FAIL.");
                        return exportImage(type);
                        break;

                    default:
                        debug("unknown png renderer given, doing noting (" + options.renderer + ")");
                }

                break;

            default:
                debug("Sorry! Exporting as '" + type + "' is not supported!")
        }
    }
    function exportChart() {
        //fix weird back fill
        d3.select('#'+"results-div").selectAll("path").attr("fill", "none");
        //fix no axes
        d3.select('#'+"results-div").selectAll("path.domain").attr("stroke", "black");
        //fix no tick
        d3.select('#'+"results-div").selectAll(".tick line").attr("stroke", "black");
        let svgElement = $('#'+"results-div").find('svg')[0];
        saveSvgAsPng(svgElement, "myChart"+""+'.png');

    }

</script>